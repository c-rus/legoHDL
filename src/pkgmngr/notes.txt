##########################
|						 |
|		legoHDL			 |
|						 |
##########################

[ ]		-allow user to disable-enable registry repo setting

[ ]		-export project as a vivado project, with symbolic links to the VHDL files

@IDEA	have downloads be referenced over installs?

@IDEA	on a version release, have a dedicated zipped file of the vhd and .yaml?
		faster for an install, but may have to be reworked if then deciding to download

[ ]		allow remote to be null,
[ ]		allow user to open settings file
[ ]		allow user to open template folder

@IDEA	movtivation behind building a Hardware HDL manager:
	  	-direct control and flexibility to design to meet variety of needs/worklfow/situations
	   	-complete customization to tackle problem of module management
		-HDL is strictly heirarchic by design. HDL is also very complex with many stages beyond simply designing a package.
		-By giving developer's the freedom, flexibility, and power to manage modules as well as provide a framework for 
		endless possibilities to building a design

@IDEA	some idea python scripts to be made:
   			toolbelt.py // helps automate use of tools for lint, anaylsis, sim
			testkit.py // module to store common functions related to testbenches
			manager.py // package manager to handle collections of IPs (THIS PROJECT!!!)

@IDEA	the dependencies folder is not tracked by git because there would be major overlap of code/resources. Code should be 
		tried to restricted into a single location. Tracking the YAML file and its list of dependencies will be enough and 
		will trigger installs when required by a download
		-> this is handled by having a cache folder where all installs are located

@NOTE	when installing dependency, follow directed acyclic graph with topological sort
@IDEA	when installing dependency, automatically paste the component declaration into top-level design


@IDEA	use filenames with the version (in dependency folder) to allow for designs that require multiple versions of a module that 
		is used by different entities

@IDEA	prompt to move all current projects to new local directory when changing setting? -> NO

@IDEA	seperate program/framework to perform lint, synth, simulation/verification, place-and-route, bitstream? 
		-> this is handled by developer's creating their own build scripts

[x]		-search all design VHD files to determine which is top-level design
		then find which testbench instantiates that design

@IDEA	alternate method: dependency folder has files that point to the git commits of those versions?

@IDEA	use 'sync tb' to sync ports of design to the testbench vhdl and across testbench.py file for use 	
		-(will also auto make generic testbench) (can be embedded into CI with analysis of design file) -toolkit.py-
		-> this is handled by "port" command printing ports to use

#eventually make a GUI with tkinter for easier & visual package management

#SCENARIO: developer is working on improving a VHDL module that has been previouly released (v1.0). Other higher-level
# module packages now use v1.0 in their design as a dependency. Developer now releases v1.1. A new moudle package now
# uses v1.1 of this lower-level module, and now another newer high-level module uses the modules that depend on v1.0 
# and the module that depends on v1.1. What's the resolve?
#   -all MINOR (0.X) version updates should try to update the dependency list of those who depend on it and rerun verification
#   to ensure module is still valid. If the build fails in CI, automate a git revert to the commit previous to the "Updates 
#   'x' dependency module version to '#.#'.
#   -all MAJOR (X.0) version updates will not automatically trigger the chain because of it has altered the core
#   functionality and can be assumed to break all other builds

#program should handle most git version control behind the scenes (pushing and pulling, maybe even tags)

#what if a developer never had to touch a VHDL file when verifying a module?
# motivation:
#   -faster development time as it is all rooted in a single source (python testbench file)
#   -VHDL files can very repetitive in nature when setting up a testbench using I/O files
#   -command-line automatic scripts will handle copying and pasting the right lines of code into the tb
#   -python is source of verification because it is very readable, easy to build up a library of helpful code, 
#   and easy to write with minimal lines
#   -software languages are the best at writing software; why try to do so in a restricted HW language in confusing ways
#   when software languages are available to do the job (there are great data science modules available scipy, matplotlib, pandas)

# a "library" is no more than a collection of VHDL files with respective packages. Every new release gets new component declarations
# for that specific version added to that project's pkg VHDL file. library "name"; use "name".projectpkg.component_ver (library.packagefile.comp)
# continually updates. The top-level to a project is the only component that gets added to the pkg file. Adding versioning to the end
# of component names may allow for preserving and using multiple designs

#scan for dependencies to update YML anytime on a "show" "export" "upload" commands
#option to disable auto-scanning thus requiring users to make a requirements.txt -> equiv as having users just type in the "use" statements
#because it is there where they are specifying the version and component

#SCAN command - update dependency list
#EXPORT command - generate a txt file to be used on any backend scripts made by user

packages can belong to a library or be their own library

library utils;
use utils.flipflopPkg.flipflop;
use utils.clockdividerPkg.clockdivider;

library encoder;
use util.enconder_pkg.encoder;

PKG VHD file is simple component wrapper;

#when a user utilizes a sub-module and releases a version with that sub-module, 
they are saying "hey, my package requires this sub-module (latest v1.2.0), and
so update the YML for the sub-module to say it integrates with upper-module, so 
that moving forward, any new releases to sub-module, with this info we can chain 
push CI jobs to try to see if upper-module will not break with new changes",
...accordingly, it should not break with all minor and patch updates.

@RELEASE 	move settings.yml to ~/.legohdl
@RELEASE	move template to ~/.legohdl


##################
======ISSUES======
##################

-upon switching from local-only to remote, a new project that was first local will not appear in catalog
until next command
-checking activity log means it is not updated every single second
-uploading and instantly dismissing a project causes the new version to not appear in catalog on next commands
-better determine when it is necessary to request from remote to improve speed of some commands


##################
======ROADMAP=====
##################


[ ]		-add verilog/systemverilog file support
[ ]		-set up remote using registry design and git repo (ex: winget)
[ ]		-implement additional "help" command documentation

[x]		-revisit using makefile as script
[x]		-give option to update and commit all changes with next "release" -ac (already was!)
[x]		-fix "-alpha" option for list command to correctly display modules' status
[x]		-implement uninstall command       
[x]		-user is able to open and edite the build scripts through legohdl
[x]		-need ability to set custom parameters from command line, like make (args can be passed to build file)
[x]		-try moving source files around and then releasing  
[x]		-fix when releasing a module to update cache and lib
[x]		-implement recursive nature on install for other dependencies
[x]		-implement cache folder

	RECIPES/BUILDING

[x]		-add way to add a recursive label (useful for labelling IP files that are needed inside dependencies)
[x]		-users specify external ext. and what the tag is to search for adding to recipe	("tags" option)	
		ex: you can set:
			@XILINX_CONSTR -> .XDC
			@QUARTUS_ROUTE -> .qpr
			@PYTHON 	   -> .py
			-when these are set (at user level), the export command will build the recipe and include these
			first
[x] 	-when setting a build script, you specify how to call it (python3, sh, make) and the file
[x]		-entering blank path to build script in config will delete it or unlink it
[x] 	-ability to set a build script file, (can be any file (TCL, make, py)) to house in 1 place
[x]		-master build script will try to run by default when running build option and no file specified

	OVERALL STRUCTURE
[ ]		-ability to set mulitple remotes to 1 local path
[ ]		-ability to set multiple local path places
[ ]		-don't set * to src dir of top level, individually add every current level vhd file from glob.glob


@IDEA	a useful byproduct of setting scripts is you cant set any file you want to be located there

@NOTE 	recipe file gives you the order of all required user files to build the design

@IDEA	if working with others, house build scripts in a repository and link to their local paths
		in legoHDL to be able to continually improve them in the same spot

@NOTE 	as of NOW, "build" is the same as "scripts", and for future should be renamed all to "scripts"
		for potential for user to store/link more than build stuff into scripts location

@IDEA	legohdl export -b <script_name?> [...] -> leaning toward no because of options already in place for export

##############
===ARCHIVES===
##############

@TEST [x]	config run="file-path" -build -lnk

@IDEA	add pin mapping to YAML file to allow program to place-and-route design post-synthesis

@IDEA	when installing dependency, allow for adding multiple dependencies in one command by using ',' between modules
		example: legoHDL install flipflop -v1.0 , combinational , asyncCounter -v2.1

-give user option to customize recipe export file, example vars are %ID% %LIB% %PATH% %TOP% %BENCH% %NAME%
	*set keywords are used to indicate how recipe should handle when writing those types
	-ex: @LIB ghdl -a    --std=08 --work=%LIB% %PATH%
	     @TB  ghdl -a -r --std=08 		 %PATH%
	     @TOP ghdl -a -e --std=$VER 		 %PATH%
	-the script will insert the line at where LIB starts and perform this for all library files at this step
	-if a section of the recipe template doesn't start with a keyword, it skips over it
	-extra option "-b" will attempt to build/run your recipe file through python os.system.

Current project build file overrides master_build and therefore master_build will have
to be called explicitly
-if no path is specified, it will auto open a blank file to fill in

saving for later use of the command structures for in-depth command help
---
formatHelp("install <package> [-v0.0.0]","fetch package from the code base to be available in current project")
formatHelp("uninstall <package>","remove package from current project along with all dependency packages")
formatHelp("download <package> [-o]","pull package from remote code base for further development")
formatHelp("upload [-v0.0.0 | -maj | -min | -fix]","release the next new version of package")
formatHelp("update <package> [-all]","update developed package to be to the latest version")
formatHelp("list [-alpha -local]","print list of all packages available from code base")
formatHelp("open <package>","opens the package with the set text-editor")
formatHelp("del <package>","deletes the package from the local code base")
formatHelp("search <package> [-local]","search remote (default) or local code base for specified package")
formatHelp("convert <package>","converts the current directory into a valid package format")
formatHelp("show <package> [-v0.0.0]","provide further detail into a specified package")
formatHelp("ports <package> [-v0.0.0]","print ports list of specified package")
formatHelp("summ [-:\"description\"]","add description to current project")
formatHelp("new <library.package> [-\"description\" -o]","create a standard empty package based on a template and pushes to remote code base")
formatHelp("config <value/path> [-local | -remote | -editor | -author]","adjust package manager settings")
formatHelp("template","open the template in the configured text-editor to make custom configuration")

